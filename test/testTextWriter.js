/* Specify environment to include mocha globals */
/* eslint-env node, mocha */

'use strict';

const expect = require('chai').expect;
const TextTransform = require('../app/writer/TextTransform.js');

/**
 * Positive testing for task
 */
describe('TextTransform', function() {
	describe('#constructor', () => {
		const tx = new TextTransform('docx');

		it('should set the format', () => {
			expect(tx.format).to.equal('docx');
		});
	});

	describe('#htmlColor', () => {
		const tx = new TextTransform('html');

		it('should return the color text in a formatted <span>', () => {
			expect(tx.htmlColor('GREEN'))
				.to.equal('<span style="font-weight:bold;color:green;">GREEN</span>');
			expect(tx.htmlColor('RED'))
				.to.equal('<span style="font-weight:bold;color:red;">RED</span>');
			expect(tx.htmlColor('YELLOW'))
				.to.equal('<span style="font-weight:bold;color:yellow;">YELLOW</span>');
		});
	});

	describe('#transform', () => {
		const tx = new TextTransform('html');

		it('should convert a single item without added whitespace', () => {
			const xformed = tx.transform('GREEN');
			expect(xformed).to.be.an('array');
			expect(xformed).to.eql([
				'<span style="font-weight:bold;color:green;">GREEN</span>'
			]);
			expect(xformed.join(''))
				.to.equal('<span style="font-weight:bold;color:green;">GREEN</span>');
		});

		it('should convert colors to html', () => {
			const xformed = tx.transform('GREEN RED GREEN RED');
			expect(xformed).to.be.an('array');
			expect(xformed).to.eql([
				'<span style="font-weight:bold;color:green;">GREEN</span>',
				' ',
				'<span style="font-weight:bold;color:red;">RED</span>',
				' ',
				'<span style="font-weight:bold;color:green;">GREEN</span>',
				' ',
				'<span style="font-weight:bold;color:red;">RED</span>'
			]);
		});

		it('should convert symbols to html', () => {
			const conversions = [
				// items that will be converted
				['{{CHECK}}', '✓'],
				['{{CHECKBOX}}', '☐'],
				['{{CHECKEDBOX}}', '☑'],
				['{{LEFT}}', '←'],
				['{{RIGHT}}', '→'],
				['ANCHOR', '<strong>ANCHOR</strong>'],

				// items that will not be converted, add 3rd item "true". See below for explanation.
				[' ', ' ', true],
				['some text', 'some text', true],
				[' other text ', ' other text ', true]
			];
			let input = '';
			const expectedOutput = [];
			let priorItemNonConverted = false;

			for (let i = 0; i < 1500; i++) {
				// get a random item from the list of conversions
				const item = conversions[Math.floor(Math.random() * conversions.length)];

				// For input construct a string
				input += item[0];

				// for expected output, construct an array. Items that do NOT get converted by
				// doTransform() should not create a new array item if they are adjacent, i.e. if an
				// string "no convert.no convert.no convert." was generated by three instances of
				// "no convert.", you'd want the array to be ["no convert.no convert.no convert."]
				// not ["no convert.", "no convert.", "no convert."]
				if (item[2] && priorItemNonConverted) {
					expectedOutput[expectedOutput.length - 1] += item[1];
				} else {
					expectedOutput.push(item[1]);
				}
				priorItemNonConverted = item[2];
			}

			const xformed = tx.transform(input);
			expect(xformed).to.be.an('array');
			expect(xformed.join('')).to.equal(expectedOutput.join(''));
			expect(xformed).to.eql(expectedOutput);
		});
	});
});
